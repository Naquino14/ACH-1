// Copyright 2021 Nathaniel Aquino, All rights reserved.
// Aquino Cryptographic Hash version 1

// this file contains all the comments

using System;
using System.IO;

namespace ACH_1_Demonstrator
{
    public class ACH1 : IDisposable // final implimentation of the class goes here
    {
        #region variables

        public InitType initType;
        private bool disposedValue;

        private bool computeSetupFlag = true;

        private byte[] prevBlock; // 1024 byte blocks
        private byte[] block;

        private byte[] output = new byte[1024]; // 1024 byte output
        private byte[] input; // raw input for digestion

        private string path;

        public enum InitType
        {
            file,
            text
        }
        private enum Type
        {
            tString,
            tByte,
            notFound
        }

        #endregion

        #region initialization and disposal methods

        public ACH1(InitType initType) => this.initType = initType;


        protected virtual void Dispose(bool disposing) // GC comes later...
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // TODO: dispose managed state (managed objects)
                }

                // TODO: free unmanaged resources (unmanaged objects) and override finalizer
                // TODO: set large fields to null

                prevBlock = null;
                block = null;
                output = null;
                input = null;
                path = null;

                disposedValue = true;
            }
        }

        public void Dispose() // do not change
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        #endregion

        #region main function

        /// <summary>
        /// Returns a 1024 bit hash using ACH-1. Parameter input must be a string or a byte[].
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public byte[] ComputeHash(object input) // for actual input, use this.input
        {
            if (computeSetupFlag)
            {
                // reset vars
                Clear();

                // type matching
                var match = TypeMatch(input);
                if (!match.success)
                    throw new ArgumentException("Parameter input has an invalid type " + input.GetType() + ".");
                bool pathFlag = false;
                switch (match.type)
                {
                    case Type.tByte:
                        this.input = (byte[])input;
                        break;
                    case Type.tString:
                        path = (string)input;
                        // grab data out the switch
                        pathFlag = true;
                        break;
                    case Type.notFound: break;
                }

                // FNK Formation
                // switch for type and case file, get the file name as the FNK, case no file, sample 64 bits from the input and pad
                // input should be ambiguous between file path and input data
                if (!GetFNK(input, out byte[] FNK))
                    throw new Exception("FNK Could not be generated");
                // grab input data in the case of a file path
                if (pathFlag)
                    this.input = File.ReadAllBytes(path);

            }
            return output;
        }

        #endregion

        #region methods and funcs

        private (bool success, Type type) TypeMatch(object input)
        {
            System.Type inputType = input.GetType();
            if (input == null)
                return (false, Type.notFound);
            if (inputType != typeof(string) || inputType != typeof(byte[]))
                return (false, Type.notFound);
            if (inputType == typeof(string))
                return (true, Type.tString);
            else
                return (true, Type.tByte);
        }

        /// <summary>
        /// Forcefully clears certain variables in ACH-1. 
        /// </summary>
        public void Clear()
        {
            output = null;
            input = null;
            path = null;
        }

        private bool GetFNK(object input, out byte[] FNK)
        {
            switch (initType)
            {
                case InitType.file:
                    string path = (string)input;
                    string fileName = path.Split('\\')[path.Split('\\').Length - 1].Split('.')[0];
                    // create 128 bytes of data from the file name.
                    byte[] byteName = Encoding.ASCII.GetBytes(fileName);
                    // make sure that the file name is below 64 bytes, and omit anything else
                    byteName = Check64BitFit(byteName);
                    if (!(byteName.Length > 64)) // and if its less, pad
                    {
                        // get the remaining slots needed, and copy them to the original array
                        int padIters = (64 - byteName.Length) / 8;
                        for (int i = 0; i <= padIters; i++)
                            byteName = AddByteToArray(byteName, FNKPad);
                        // check 1 more time to see if its below 64 bits
                        byteName = Check64BitFit(byteName);
                    }
                    // if all goes well, output the fnk after otping with the FNKPad
                    // create a 64 byte key with FNKPad
                    byte[] FNKOTPKey = new byte[] { FNKPad };
                    for (int i = 0; i <= 64; i++)
                        FNKOTPKey = AddByteToArray(FNKOTPKey, FNKPad);
                    // otp with the bytename and the key
                    FNK = AddArray(OTPArray(byteName, FNKOTPKey), OTPArray(byteName, FNKOTPKey));
                    return true;
                case InitType.text:
                    // sample 64 bytes of data from the main block
                    for (int i = 0; i <= 64; i++)
                    {

                    }
                    break;
            }

            FNK = null; return false;
        }

        private byte[] FCrray(byte[] input, int s, int c)
        {
            byte[] result = new byte[c];
            Array.Copy(input, s, result, 0, c);
            return result;
        }

        private byte[] AddArray(byte[] a, byte[] b)
        {
            byte[] result = new byte[a.Length + b.Length];
            a.CopyTo(result, 0);
            b.CopyTo(result, a.Length);
            return result;
        }

        private byte[] AddByteToArray(byte[] a, byte b)
        {
            byte[] result = new byte[a.Length + 1];
            a.CopyTo(result, 0);
            result[result.Length - 1] = b;
            return result;
        }

        private byte[] Check64BitFit(byte[] input)
        {
            if (input.Length > 64)
            { FCrray(input, 0, 64); return input; }
            else
                return input;
        }

        private byte[] OTPArray (byte[] input, byte[] key)
        {
            byte[] result = new byte[input.Length];
            for (int i = 0; i < input.Length; i++)
                result[i] = (byte)(input[i] ^ key[i]);
            return result;
        }
        #endregion
    }
}
